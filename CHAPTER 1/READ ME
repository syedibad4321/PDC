Chapter 1: Python Basics, Classes, Factorial, Threading & Multiprocessing
1. Overview

Chapter 1 introduces the fundamentals of Python programming and demonstrates the following concepts:

Basic Python Functions:

Understanding how to define and call functions.

Example: Calculating the factorial of a number using recursion.

Concepts of arguments, return values, and recursion depth.

Object-Oriented Programming (OOP):

Defining classes and creating objects (instances).

Differentiating between instance variables and class variables.

Understanding inheritance, where a child class can use and override parent class methods.

Example: Myclass with shared class variable and AnotherClass inheriting from it.

Key takeaway: How variables and methods behave differently for instances vs classes.

Serial Execution:

Running tasks one by one in a single process.

Simple but can be slow for large or repetitive computations.

Useful for understanding program flow and logic before introducing concurrency.

Threading (Multithreading):

Running multiple tasks concurrently within the same process.

Threads share the same memory space, so data can be accessed by multiple threads.

Good for I/O-bound tasks (like reading files, network requests), but less effective for CPU-heavy tasks in Python due to the Global Interpreter Lock (GIL).

Key takeaway: Understand concurrency and when threads are beneficial.

Multiprocessing:

Running multiple tasks in separate CPU processes.

Each process has its own memory space, which avoids GIL limitations.

Ideal for CPU-bound tasks like heavy calculations (factorials, large list processing).

Using a shared memory manager allows processes to share data safely.

Key takeaway: True parallel execution and performance improvement on multi-core CPUs.

Performance Comparison:

Serial execution is simple but slow for heavy tasks.

Threading allows tasks to run concurrently but may not speed up CPU-heavy work.

Multiprocessing provides real parallelism and reduces execution time for CPU-intensive computations.

Observing execution times helps understand the benefits and limitations of each approach.

Factorial Example Logic:

Factorials are computed using recursion.

To speed up computation for multiple numbers:

Each number can be calculated in parallel using multiprocessing, with each process computing one factorial.

Threads could also be used, but due to GIL, performance gain may be limited for CPU-heavy factorial calculation.

Key takeaway: Applying threading and multiprocessing in a real example solidifies understanding of Python concurrency concepts.